#include "window.h"
#include <iostream>
#include <xcb/xcb_icccm.h>
#include <logging.h>
#include <cstring>
#include <stopwatch.h>

Window::Window(xcb_connection_t *conn, xcb_screen_t *scr, const WindowConfig &cfg, const Scene &scene)
 : connection(conn), screen(scr), window(0), gc(0), config(cfg), scene(scene)
{
    createWindow();
    createPixmap();
    setupGraphicsContext(screen->black_pixel, 0xffffffff);
    clearWindow();
}

Window::~Window()
{
    if (gc)
    {
        xcb_free_gc(connection, gc);
        gc = 0;
    }

    if (image)
    {
        if (image->data)
        {
            delete[] image->data;
            image->data = nullptr;
        }
        image = nullptr; // not owned by us but by xcb
    }

    if (pixmap)
    {
        xcb_free_pixmap(connection, pixmap);
        pixmap = 0;
    }

    if (window)
        xcb_destroy_window(connection, window);
}

void Window::createWindow()
{
    window = xcb_generate_id(connection);
    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
    uint32_t values[2] = {screen->black_pixel, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS};

    xcb_create_window(connection, XCB_COPY_FROM_PARENT, window, screen->root,
                      config.x, config.y, config.width, config.height, 0,
                      XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      mask, values);

    // Initialize and set position hints correctly
    xcb_size_hints_t hints;
    memset(&hints, 0, sizeof(hints)); // Important: Initialize the hints structure
    xcb_icccm_size_hints_set_position(&hints, 1, config.x, config.y);
    xcb_icccm_set_wm_normal_hints(connection, window, &hints);

    xcb_map_window(connection, window);
    xcb_flush(connection);
}

void Window::createPixmap()
{
    uint8_t depth = 24; // Full color depth
    uint8_t bpp = 32;   // Bits per pixel
    uint8_t *buffer = new uint8_t[config.width * config.height * (bpp / 8)];
    image = xcb_image_create(config.width, config.height,
                             XCB_IMAGE_FORMAT_Z_PIXMAP,
                             32,
                             depth,
                             bpp,
                             32, // scanline pad, should match bpp
                             XCB_IMAGE_ORDER_LSB_FIRST,
                             XCB_IMAGE_ORDER_LSB_FIRST,
                             buffer,
                             config.width * config.height * (bpp / 8),
                             buffer);

    // Create pixmap for double buffering
    pixmap = xcb_generate_id(connection);
    xcb_create_pixmap(connection, screen->root_depth, pixmap, window, config.width, config.height);

    // Setup graphics context if needed
    gc = xcb_generate_id(connection);
    uint32_t values[2] = {screen->black_pixel, screen->white_pixel};
    xcb_create_gc(connection, gc, pixmap, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND, values);
}

void Window::setupGraphicsContext(uint32_t background, uint32_t foreground)
{
    gc = xcb_generate_id(connection);
    uint32_t mask = XCB_GC_FOREGROUND | XCB_GC_BACKGROUND | XCB_GC_GRAPHICS_EXPOSURES;
    uint32_t values[3] = {foreground, background, 0};    // Ensure these are set correctly
    xcb_create_gc(connection, gc, pixmap, mask, values); // Make sure gc is for pixmap
}

void Window::clearWindow()
{
    for (int y = 0; y < config.height; y++)
        for (int x = 0; x < config.width; x++)
        {
            int idx = (y * config.width + x) * 4;
            image->data[idx] = 0;
            image->data[idx + 1] = 0;
            image->data[idx + 2] = 0;
            image->data[idx + 3] = 0;
        }
}

void Window::handleEvent(xcb_generic_event_t *event)
{
    switch (event->response_type & ~0x80)
    { // The ~0x80 masks out the highest bit used to indicate an event generated by SendEvent
    case XCB_EXPOSE:
        clearWindow();
        break;
    }
}


void Window::draw()
{
    int sessionId = Stopwatch::start("Window.Draw");
    renderScreen();
    Stopwatch::stop("Window.Draw", sessionId);

    sessionId = Stopwatch::start("Window.CopyBuffers");
    xcb_image_put(connection, pixmap, gc, image, 0, 0, 0); // Render the image to the pixmap
    xcb_copy_area(connection, pixmap, window, gc, 0, 0, 0, 0, config.width, config.height); // Copy the pixmap to the window
    Stopwatch::stop("Window.CopyBuffers", sessionId);

    xcb_flush(connection);
}

void Window::flush()
{
    xcb_flush(connection);
}

void Window::refresh()
{
    xcb_copy_area(connection, pixmap, window, gc, 0, 0, 0, 0, config.width, config.height);
    xcb_flush(connection);
}