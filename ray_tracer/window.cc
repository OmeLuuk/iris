#include "window.h"
#include <iostream>
#include <xcb/xcb_icccm.h>
#include <logging.h>
#include <cstring>

Window::Window(xcb_connection_t *conn, xcb_screen_t *scr, const WindowConfig &cfg)
 : connection(conn), screen(scr), window(0), gc(0), config(cfg)
{
    createWindow();
    setupGraphicsContext(screen->white_pixel);
    clearWindow();
}

Window::~Window()
{
    if (gc)
    {
        xcb_free_gc(connection, gc);
    }
    if (window)
    {
        xcb_destroy_window(connection, window);
    }
}

void Window::createWindow()
{
    window = xcb_generate_id(connection);
    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
    uint32_t values[2] = {screen->black_pixel, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS};

    xcb_create_window(connection, XCB_COPY_FROM_PARENT, window, screen->root,
                      config.x, config.y, config.width, config.height, 0,
                      XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      mask, values);

    // Initialize and set position hints correctly
    xcb_size_hints_t hints;
    memset(&hints, 0, sizeof(hints)); // Important: Initialize the hints structure
    xcb_icccm_size_hints_set_position(&hints, 1, config.x, config.y);
    xcb_icccm_set_wm_normal_hints(connection, window, &hints);

    xcb_map_window(connection, window);
    xcb_flush(connection);
}

void Window::setupGraphicsContext(uint32_t color)
{
    gc = xcb_generate_id(connection);
    uint32_t mask = XCB_GC_FOREGROUND;
    uint32_t values[1] = {color};
    xcb_create_gc(connection, gc, window, mask, values);
}

void Window::clearWindow()
{
    xcb_rectangle_t rect = {0, 0, config.width, config.height};
    xcb_poly_fill_rectangle(connection, window, gc, 1, &rect);
    xcb_flush(connection);
}

void Window::handleEvent(xcb_generic_event_t *event)
{
    switch (event->response_type & ~0x80)
    { // The ~0x80 masks out the highest bit used to indicate an event generated by SendEvent
    case XCB_KEY_PRESS:
        closeWindow();
        break;
    case XCB_EXPOSE:
        clearWindow();
        break;
    }
}

void Window::closeWindow()
{
    log(LL::INFO, "Closing window");

    if (window)
    {
        xcb_destroy_window(connection, window);
        window = 0; // Reset the window handle after destruction
    }
    if (gc)
    {
        xcb_free_gc(connection, gc);
        gc = 0; // Reset the graphics context handle after freeing it
    }
    xcb_flush(connection); // Ensure all commands sent to the X server are processed
}