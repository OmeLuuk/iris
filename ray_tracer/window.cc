#include "window.h"
#include <iostream>
#include <xcb/xcb_icccm.h>
#include <logging.h>
#include <cstring>

Window::Window(xcb_connection_t *conn, xcb_screen_t *scr, const WindowConfig &cfg, const Scene &scene)
 : connection(conn), screen(scr), window(0), gc(0), config(cfg), scene(scene)
{
    createWindow();
    createPixmap();
    setupGraphicsContext(screen->black_pixel, 0xffffffff);
    clearWindow();
}

Window::~Window()
{
    if (gc)
    {
        xcb_free_gc(connection, gc);
        gc = 0;
    }

    if (image)
    {
        if (image->data)
        {
            delete[] image->data;
            image->data = nullptr;
        }
        image = nullptr; // not owned by us but by xcb
    }

    if (pixmap)
    {
        xcb_free_pixmap(connection, pixmap);
        pixmap = 0;
    }

    if (window)
        xcb_destroy_window(connection, window);
}

void Window::createWindow()
{
    window = xcb_generate_id(connection);
    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
    uint32_t values[2] = {screen->black_pixel, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS};

    xcb_create_window(connection, XCB_COPY_FROM_PARENT, window, screen->root,
                      config.x, config.y, config.width, config.height, 0,
                      XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      mask, values);

    // Initialize and set position hints correctly
    xcb_size_hints_t hints;
    memset(&hints, 0, sizeof(hints)); // Important: Initialize the hints structure
    xcb_icccm_size_hints_set_position(&hints, 1, config.x, config.y);
    xcb_icccm_set_wm_normal_hints(connection, window, &hints);

    xcb_map_window(connection, window);
    xcb_flush(connection);
}

void Window::createPixmap()
{
    
}

void Window::setupGraphicsContext(uint32_t background, uint32_t foreground)
{
    gc = xcb_generate_id(connection);
    uint32_t mask = XCB_GC_FOREGROUND | XCB_GC_BACKGROUND | XCB_GC_GRAPHICS_EXPOSURES;
    uint32_t values[3] = {foreground, background, 0};    // Ensure these are set correctly
    xcb_create_gc(connection, gc, pixmap, mask, values); // Make sure gc is for pixmap
}

void Window::clearWindow()
{
    xcb_rectangle_t rect = {0, 0, config.width, config.height};
    xcb_poly_fill_rectangle(connection, pixmap, gc, 1, &rect); // Use pixmap instead of window
    xcb_flush(connection);
}

void Window::handleEvent(xcb_generic_event_t *event)
{
    switch (event->response_type & ~0x80)
    { // The ~0x80 masks out the highest bit used to indicate an event generated by SendEvent
    case XCB_KEY_PRESS:
        closeWindow();
        break;
    case XCB_EXPOSE:
        clearWindow();
        break;
    }
}

void Window::closeWindow()
{
    log(LL::INFO, "Closing window");

    if (window)
    {
        xcb_destroy_window(connection, window);
        window = 0; // Reset the window handle after destruction
    }
    if (gc)
    {
        xcb_free_gc(connection, gc);
        gc = 0; // Reset the graphics context handle after freeing it
    }
    xcb_flush(connection); // Ensure all commands sent to the X server are processed
}

void Window::drawPixel(uint16_t x, uint16_t y, uint32_t color)
{
    uint32_t value_list[1] = {color};
    xcb_change_gc(connection, gc, XCB_GC_FOREGROUND, value_list);
    xcb_point_t point = {x, y};
    xcb_poly_point(connection, XCB_COORD_MODE_ORIGIN, pixmap, gc, 1, &point); // Draw on pixmap
}

void Window::flush()
{
    xcb_flush(connection);
}

void Window::refresh()
{
    xcb_copy_area(connection, pixmap, window, gc, 0, 0, 0, 0, config.width, config.height);
    xcb_flush(connection);
}